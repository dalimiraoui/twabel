
using System.Security.Cryptography;
using Microsoft.Extensions.Logging;
using Twabel.CrossCutting.IHelpers;

namespace Twabel.CrossCutting.Helpers
{
    public sealed class PasswordEncryptService : IPasswordEncryptService
    {
        private const int SALT_SIZE = 16; // 128 bit
        private const int KEY_SIZE = 32; // 256 bit
        private const int ITERATIONS = 10000;

        private readonly ILogger<PasswordEncryptService> _logger;

        public PasswordEncryptService(ILogger<PasswordEncryptService> logger)
        {
            _logger = logger;
        }

        public string Encrypt(string password)
        {
            using (var algorithm = new Rfc2898DeriveBytes(password, SALT_SIZE, ITERATIONS, HashAlgorithmName.SHA512))
            {
                var key = Convert.ToBase64String(algorithm.GetBytes(KEY_SIZE));
                var salt = Convert.ToBase64String(algorithm.Salt);

                return $"{salt}.{key}";
            }
        }

        public bool CheckIfMatch(string hash, string password)
        {
            var parts = hash.Split('.', 2);

            if (parts.Length != 2)
            {
                throw new FormatException("Unexpected hash format. Should be formatted as `{salt}.{hash}`");
            }

            var salt = Convert.FromBase64String(parts[0]);
            var key = Convert.FromBase64String(parts[1]);

            using (var algorithm = new Rfc2898DeriveBytes(password, salt, ITERATIONS, HashAlgorithmName.SHA512))
            {
                return algorithm.GetBytes(KEY_SIZE).SequenceEqual(key);
            }
        }
    }
}
/*
This is a C# implementation of a password encryption and validation service. It uses the Rfc2898DeriveBytes class to generate a key from a given password and salt. The encryption function takes a password and generates a salt and key using the Rfc2898DeriveBytes class with SHA512 as the hash algorithm. The salt and key are then concatenated and returned as a string in the format of "{salt}.{key}".

The CheckIfMatch function takes a hash (previously generated by the Encrypt function) and a password. It splits the hash into its salt and key parts and converts them from base64 strings back into byte arrays. It then uses the Rfc2898DeriveBytes class with the salt and password to generate a key and compares it with the key extracted from the hash using the SequenceEqual method. If they match, it returns true, indicating that the password is valid. If they do not match, it returns false.

This implementation uses a fixed salt size of 16 bytes (128 bits), a key size of 32 bytes (256 bits), and 10000 iterations of the hash function. These values can be adjusted to increase or decrease the strength of the encryption

*/